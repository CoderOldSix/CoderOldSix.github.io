---
title: 【UE C++】接口
author: CoderOldSix
date: 2022-07-02 00:55:00 +0800
categories: [HLSL, DX, Shader]
tags: [UE4, DX, Shader]
pin: true
---

# UE	C++接口

### 接口

UE语言具备C++多继承特性，但是由于UE对C++进行了深度定制，强制了继承自UObject的类只能继承一个具有完整属性行为的父类，其他继承关系以接口来实现，接口只定义了行为的框架，不具有具体的逻辑行为（无实现），需要继承自接口的类自己实现接口逻辑。

### 接口优点 

1.具备多态特性，接口衍生类支持里氏转换原则（子类可以向父类合理转换） ；

2.接口可以使得整个继承系统更加的干净单一 ；

3.接口可以规范类的具体行为，继承自接口的类必须实现接口内的所有行为 ；

4.接口可以隔离开发中的开发耦合，我们只需要针对接口进行编程，无需关心对接逻辑的实现；

5.接口继承可以使得继承关系中出现真正的父类；

### 接口缺点 

1.失去了C++中的广泛继承特性 ；

2.接口拘束了类型的属性拓展，无法进行更详细的内容定义 ；

3.继承关系中容易让人混淆，接口本身不具备真正的继承特性；

### UE中的接口操作

1.继承UObject然后开始改良 

2.确认接口名称，需要构建两个类，分别使用U和I进行类名前缀标记 

3.U类名上加入宏UINTERFACE(Blueprintable)，并继承UInterface 

4.U类内加入宏 GENERATED_UINTERFACE_BODY() 

5.I类内加入宏GENERATED_IINTERFACE_BODY() 

6.在CPP文件中加入U类构造函数实现，U类头文件中无需加入函数声明，此函数由宏进行构建语法如下 U类名：：U类名(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer) 

7.接口函数定在I类中，标记为public，并引入头文件 

8.继承类中继承接口I类，标记继承关系public 

9.在继承类中实现接口函数，并添加后缀_Implementation，需要注意，函数前加入虚函数关键字virtual，函数结尾加override关键字 

10.在对象继承接口的CPP中实现函数，编写逻辑，和普通函数一样 _

_11.调用函数，持有继承接口对象指针，第一步先转换到I类型接口指针，使用Execute_接口函数名，参数第一位需要传递原对象指针，后面直接编写函数即可 

12.检查某一个类是否实现了对应接口可以使用如下语法进行检查 obj->GetClass()->ImplementsInterface(U类型：：StaticClass（）); 建议通过Unreal内部接口模板进行构建，即创建接口类时可以通过Unreal Interface进行构建，可以直接跳过8以前步骤

## 代理

为了解决回调通知中，对象类型不同，无法使用同一容器进行存储的问题。主要达到的目的是调用某个对象的函数，可以不知道对象类型也可以完成操作。  UE中的代理分为 **单播代理 多播代理**

### 单播代理

只进行一个目标对象的通知

构建单播代理需要注意，构建宏分为两种，一种是有返回类型的构建宏，一种是没有返回类型的构建宏

**函数**
BindUObject 绑定UObject类型对象成员函数的代理
BindSP 绑定基于共享引用的成员函数代理
BindRaw 绑定原始自定义对象成员函数的代理，操作调用需要注意执行需要检查IsBound
BindStatic 绑定全局函数成为代理
UnBind 解除绑定代理关系

**调用**
为了保证调用的安全性，执行Execute函数之前需要检查是否存在有效绑定使用函数IsBound
Execute   调用代理通知，不安全，需要注意
ExecuteIfBound   调用代理通知，安全，但是有返回类型的回调函数无法使用此函数执行回调
IsBound  检查当前是否存在有效代理绑定

**构建步骤**
1.通过宏进行声明代理对象类型（根据回调函数选择不同的宏）
2.使用代理类型进行构建代理对象
3.绑定回调对象，和操作函数
4.执行代理对象回调

### 多播代理

实现目标效果，可以达到一对多的广播回调  UE中的多播缺陷无法进行绑定有返回类型的函数  多播代理无法使用带有返回值的函数进行构建 

**构建宏** 

DECLARE_MULTICAST_DELEGATE_OneParam(DelegateMulOne, int32); 

支持多参数传递，需要选择不同的宏进行构建 

**函数**  

AddUObject 添加一个Uob类型对象的成员函数为代理 

AddStatic 添加一个全局函数为代理函数 

AddSP 添加一个基于共享指针的成员函数为代理 

AddRaw 添加一个由C++构建的函数为代理 Remove  将函数从多播代理中移除 

RemoveAll 清空多播代理列表 

**广播** 

调用函数Broadcast，但是调用不保证执行顺序的正确性，调用之前必须需要检查IsBound是否有效   

**构建步骤** 

1.使用宏构建代理类型 

2.使用代理类型构建多播代理对象 

3.添加绑定代理 

4.执行调用 **移除操作** 添加函数到多播代理队列时会返回代理句柄，可用于移除时提供句柄参数使用，帮助我们移除指定的函数出代理队列 Remove（FDelegateHandle）

## 事件Event

事件本身和多播代理一样，只是为了代理对象的安全性，事件提供了额外的操作限定，即禁止在声明事件对象的外部调用事件传播，清理，检查等函数，通过操作隔离，最大程度的增加了事件的安全性。派生类允许调用事件的广播。
**构建宏**
DECLARE_EVENT_OneParam(ALeassonUECPPGameModeBase, DelEventOne, int32);

事件类型构建宏由于需要限定事件对象调用约束关系，需要提供声明所在类型

**函数**
AddUObject  添加一个Uob类型对象的成员函数为代理
AddStatic 添加一个全局函数为代理函数
AddSP  添加一个基于共享指针的成员函数为代理
AddRaw 添加一个由C++构建的函数为代理
Remove   将函数从多播代理中移除
RemoveAll 清空多播代理列表

**广播**
调用函数Broadcast，但是调用不保证执行顺序的正确性，调用之前必须需要检查IsBound是否有效

**移除操作**
添加函数到多播代理队列时会返回代理句柄，可用于移除时提供句柄参数使用，帮助我们移除指定的函数出代理队列
Remove（FDelegateHandle）

**构建步骤**
1.使用宏构建代理类型
2.使用代理类型构建多播代理对象
3.添加绑定代理
4.执行调用



---

​			"Time after time have given me new courage to face life cheerfully, have been Kindness, *Beauty, and Truth.* "   ---Albert Einstein

---

